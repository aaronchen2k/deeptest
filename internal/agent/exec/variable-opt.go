package agentExec

import (
	"github.com/aaronchen2k/deeptest/internal/pkg/consts"
	"github.com/aaronchen2k/deeptest/internal/pkg/domain"
)

// GetVariable
// @Param	processorId	int			true	"Processor Id"
// @Param	nameOrExpr	string		true	"Variable name(email) or prop expression(address.city)"
func GetVariable(processorId uint, nameOrExpr string) (ret domain.ExecVariable, err error) {
	/** for interface debug:
	  	    Dynamic Vars: generated by current interface's earlier pre/post conditions (agent side)
	  	    Shared Vars:  generated by other interface in same serve                   (server side)
	  								   other processor(interface) in same scenario     (server side)

	    for scenario exec:
	  	    Dynamic Vars: generated by earlier processors including interface pre/post conditions (agent side)
	  	    Shared Vars:  generated by other interface in same serve                              (server side)
	  **/

	// priority 1: Dynamic Vars, generated by execution (extractor, condition script, processor)
	ret, err = getDynamicVariableFromScope(processorId, nameOrExpr)
	if ret.Name != "" {
		return
	}

	// priority 2: Shared Vars, for interface debug from server side
	//             A. shared vars generated by Interface Debug in same serve
	//			   B. shared vars generated by Extractor and Processor in scenario
	ret, err = getVariableFromShareVar(nameOrExpr)
	if ret.Name != "" {
		return
	}

	// priority 3: Environment Vars, in project's serve settings
	ret, err = getVariableFromEnvVar(nameOrExpr)
	if ret.Name != "" {
		return
	}

	// priority 4: Global Vars, on project level
	ret, err = getVariableFromGlobalVar(nameOrExpr)
	if ret.Name != "" {
		return
	}

	return
}

// SetVariable
// @Param	processorId	int			true	"Processor Id, 0 if NOT executed by a scenario processor"
func SetVariable(processorId uint, variableName string, variableValue interface{}, variableType consts.ExtractorResultType, scope consts.ExtractorScope) (
	newVariable domain.ExecVariable, err error) {

	found := false

	//value, valueType := commUtils.GetValueInfo(variableValue)

	newVariable = domain.ExecVariable{
		Name:      variableName,
		Value:     variableValue,
		ValueType: variableType,
		Scope:     scope,
	}

	allValidIds := &[]uint{uint(0)}
	if processorId > 0 {
		allValidIds = ScopeHierarchy[processorId]
	}

	for _, id := range *allValidIds {
		for i := 0; i < len(ScopedVariables[id]); i++ {
			if ScopedVariables[id][i].Name == variableName {
				ScopedVariables[id][i] = newVariable

				found = true
				break
			}
		}
	}

	if !found {
		ScopedVariables[processorId] = append(ScopedVariables[processorId], newVariable)
	}

	return
}

func ClearVariable(processorId uint, variableName string) (err error) {
	deleteIndex := -1

	targetScopeId := uint(0)

	allValidIds := ScopeHierarchy[processorId]
	if allValidIds != nil {
		for _, id := range *ScopeHierarchy[processorId] {
			for index, item := range ScopedVariables[id] {
				if item.Name == variableName {
					deleteIndex = index
					targetScopeId = id
					break
				}
			}
		}
	}

	if deleteIndex > -1 {
		if len(ScopedVariables[targetScopeId]) == deleteIndex+1 {
			ScopedVariables[targetScopeId] = make([]domain.ExecVariable, 0)
		} else {
			ScopedVariables[targetScopeId] = append(
				ScopedVariables[targetScopeId][:deleteIndex], ScopedVariables[targetScopeId][(deleteIndex+1):]...)
		}
	}

	return
}
